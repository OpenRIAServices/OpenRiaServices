pool:
  vmImage: 'windows-2025'

variables:
  BuildConfiguration: 'release'
  BuildPlatform: 'any cpu'
  Solution: 'src\RiaServices.sln'
  # Msbuild might create logs in the following directory in case some of the "tool" tests fail
  MSBUILDDEBUGPATH: $(Build.ArtifactStagingDirectory)
  # Define the following variable for the build pipeline in order to enable SonarCloud analysis
  # sonarcloud-endpoint: 'sonarcloud.io'

steps:

# Uncomment below to install dotnet runtime and SDK if they stop beeing preinstalled
## install dotnet 8
- task: UseDotNet@2
  inputs:
    packageType: 'sdk'
    version: '8.0.x'

## install dotnet 8 sdk
- task: UseDotNet@2
  inputs:
    packageType: 'sdk'
    version: '10.0.x'

- task: NuGetToolInstaller@1
  inputs:
    versionSpec: 7.0.0

- task: gitversion/setup@3
  inputs:
    versionSpec: '5.9.0'

- task: gitversion/execute@3
  displayName: 'Use GitVersion'

- task: NuGetCommand@2
  displayName: 'NuGet restore RiaServices.sln'
  inputs:
    restoreSolution: '$(Solution)'
    configuration: '$(BuildConfiguration)'

- task: SonarCloudPrepare@3
  displayName: 'Prepare analysis on SonarCloud'
  condition: variables['sonarcloud-endpoint']
  inputs:
    SonarCloud: 'sonarcloud.io'
    organization: 'openriaservices'
    scannerMode: 'dotnet'
    projectKey: 'OpenRIAServices_OpenRiaServices'
    projectName: 'OpenRiaServices'
    projectVersion: '$(Build.BuildNumber)'
    extraProperties: |
      # Additional properties that will be passed to the scanner, 
      # Put one key=value per line, example:

- task: VSBuild@1
  displayName: 'Build solution RiaServices.sln'
  inputs:
    solution: '$(Solution)'
    platform: '$(BuildPlatform)'
    configuration: '$(BuildConfiguration)'
    maximumCpuCount: true

# Load test databases and setup msbuild debug path so it becomes part of artifacts 
- powershell: |
    sqllocaldb start MSSQLLocalDB
    if (-not $?) { write-error  "failed to start  MSSQLLocalDB" }

    .\Setup-TestDatabases.ps1
  displayName: 'Setup database'

- task: VSTest@3
  displayName: 'Run tests - .NET Framework'
  enabled: false
  inputs:
    testAssemblyVer2: |
      **\bin\$(BuildConfiguration)\net4*\OpenRiaServices.*Test.dll
      !src\VisualStudio\**\bin\$(BuildConfiguration)\net4*\OpenRiaServices.*Test.dll
      !**\bin\$(BuildConfiguration)\*\OpenRiaServices.Common*Test.dll
      src\VisualStudio\Tools\Test\bin\$(BuildConfiguration)\net4*\OpenRiaServices.VisualStudio.*.Test.dll
      !**\obj\**

    runOnlyImpactedTests: false
    runInParallel: true
    runSettingsFile: 'src\test.runsettings'
    codeCoverageEnabled: true
    platform: '$(BuildPlatform)'
    configuration: '$(BuildConfiguration)'
  timeoutInMinutes: 25
# todo, START AspNetCoreWebsite.exe in background (before test) to enable these tests
# Can we start process monitor to capture any file/registry access violations during the tests?

- script:
    set ASPNETCORE_ENVIRONMENT=Development
    src\Test\AspNetCoreWebsite\bin\$(BuildConfiguration)\net10.0\AspNetCoreWebsite.exe --urls http://localhost:5247/
  displayName: 'Display dotnet info'
  timeoutInMinutes: 1
  continueOnError: true

# Pseudocode plan:
# 1. Download Procmon.exe to the agent (if not already present).
# 2. Start Procmon in the background before the ".NET 10" test task, set it to capture all events, and save the log to $(Build.ArtifactStagingDirectory)\procmon.pml.
# 3. Run the test task as usual.
# 4. After the test task, stop Procmon and ensure the log is saved.
# 5. Optionally, copy the log to artifacts if not already in the right place.

# Insert before the "Run tests - .NET 10" task:
- powershell: |
    $procmonUrl = "https://live.sysinternals.com/Procmon.exe"
    $procmonDir = "$(Agent.TempDirectory)\procmon"
    $procmonExe = "$procmonDir\Procmon.exe"
    $logPath = "$(Build.ArtifactStagingDirectory)\procmon.pml"

    mkdir $procmonDir | Out-Null
    Invoke-WebRequest -Uri $procmonUrl -OutFile $procmonExe

    # Start Procmon in the background, capturing all events, auto-accept EULA, and save to log
    Start-Process -FilePath $procmonExe -ArgumentList "/Minimized /Quiet /AcceptEula /Backingfile $logPath" -WindowStyle Hidden
  displayName: 'Start Procmon to capture system activity'
  timeoutInMinutes: 2

- task: VSTest@3
  displayName: 'Run tests - .NET 10'
  inputs:
    testAssemblyVer2: |
      **\bin\$(BuildConfiguration)\net10.0\OpenRiaServices.*Test.dll
      !**\bin\$(BuildConfiguration)\*\OpenRiaServices.Common*Test.dll
      !**\obj\**

    runOnlyImpactedTests: false
    runInParallel: true
    runSettingsFile: 'src\test.runsettings'
    codeCoverageEnabled: true
    platform: '$(BuildPlatform)'
    configuration: '$(BuildConfiguration)'
    diagnosticsEnabled: true
  timeoutInMinutes: 25
  continueOnError: true

# Insert immediately after the "Run tests - .NET 10" task:
- powershell: |
    $procmonDir = "$(Agent.TempDirectory)\procmon"
    $procmonExe = "$procmonDir\Procmon.exe"
    $logPath = "$(Build.ArtifactStagingDirectory)\procmon.pml"

    # Stop Procmon and flush the log
    & $procmonExe /Terminate
    Start-Sleep -Seconds 5
    # Ensure the log file exists
    if (!(Test-Path $logPath)) {
      Write-Error "Procmon log not found at $logPath"
    }
  displayName: 'Stop Procmon and finalize log'
  timeoutInMinutes: 2
  condition: always

- task: DotNetCoreCLI@2
  displayName: 'Run tests - .NET'
  inputs:
    command: 'test'
    projects: |
      **/OpenRiaServices.*Test.dll
      !**/OpenRiaServices.Common*Test.dll
      !**/net4*/OpenRiaServices.*Test.dll
      !**/net10.0/OpenRiaServices.*Test.dll
      !**/obj/**
    arguments: '--configuration $(BuildConfiguration) --no-build --blame-crash --collect:"Code Coverage" --settings src/test.runsettings --logger trx'
    publishTestResults: true
    testRunTitle: 'Run tests - .NET'
  timeoutInMinutes: 25

- task: SonarCloudAnalyze@3
  inputs:
    jdkversion: 'JAVA_HOME_21_X64'
  displayName: 'Run Code Analysis'
  continueOnError: true
  condition: and(variables['sonarcloud-endpoint'], or(succeeded(), and(succeededOrFailed(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))))

- task: NuGetCommand@2
  displayName: 'NuGet pack'
  inputs:
    command: pack
    packagesToPack: 'NuGet\**\*.nuspec'
    versioningScheme: byEnvVar
    versionEnvVar: Build.BuildNumber
    packDestination: '$(Build.ArtifactStagingDirectory)'
  continueOnError: true
#  condition: and(succeeded(), ne(variables['Build.Reason'], 'PullRequest'))

- task: CopyFiles@2
  displayName: 'Copy VS Extension: $(build.artifactstagingdirectory)'
  inputs:
    SourceFolder: '$(build.sourcesdirectory)'
    Contents: |
      src\VisualStudio\Installer\bin\$(BuildConfiguration)\*.vsix
      src\VisualStudio\Installer\publishManifest.json
      src\VisualStudio\Installer\assets\**
    TargetFolder: '$(build.artifactstagingdirectory)'
  condition: and(succeeded(), ne(variables['Build.Reason'], 'PullRequest'))

- task: CopyFiles@2
  displayName: 'Copy dump files  to $(build.artifactstagingdirectory)'
  inputs:
    SourceFolder: '$(Agent.TempDirectory)'
    Contents: |
      TestResults/*/*
      **/*.diag
      !TestResults/*/*.coverage*
    TargetFolder: '$(build.artifactstagingdirectory)/vstest'
  condition: succeededOrFailed()

- task: PublishBuildArtifacts@1
  displayName: 'Publish Artifact: drop'
  inputs:
    PathtoPublish: '$(build.artifactstagingdirectory)'
  condition: succeededOrFailed()

- task: SonarCloudPublish@3
  displayName: 'Publish Quality Gate Result'
  continueOnError: true
  condition: and(variables['sonarcloud-endpoint'], or(succeeded(), and(succeededOrFailed(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))))
